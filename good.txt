import logging
import sqlite3
import csv
import io
import re
from datetime import datetime, date
from typing import Optional
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ContextTypes,
    filters,
)

# --- CONFIGURATION ---
# Replace with your actual values
BOT_TOKEN = "8420582565:AAHM4qR-nN6iheHTO20TnEYFfJqngb5mVco"
ADMIN_GROUP_ID = -1003238857423 

# --- KHMER LANGUAGE & UI CONSTANTS (Modern Enterprise) ---
LANG = {
    # Headers
    "header_welcome": "ğŸ¢ <b>á”áŸ’ášá–áŸá“áŸ’á’á‡áŸ†á“á½á™á¢áá·áá·á‡á“ (ENTERPRISE SUPPORT)</b>",
    "header_ticket": "ğŸ« <b>á”áŸááŸ’ááŸáŸ†áá¾á›áŸá (TICKET)</b>",
    "header_reply": "ğŸ‘¨â€ğŸ’¼ <b>á…á˜áŸ’á›á¾á™áá” (RESPONSE):</b>\n",
    "header_broadcast": "ğŸ“¢ <b>áŸáŸá…á€áŸ’áá¸á‡á¼á“áŠáŸ†áá¹á„ (ANNOUNCEMENT)</b>",
    "header_report": "ğŸ“Š <b>ášá”á¶á™á€á¶ášááŸ (REPORT DASHBOARD)</b>",
    "header_userlist": "ğŸ‘¥ <b>á”á‰áŸ’á‡á¸á¢áŸ’á“á€á”áŸ’ášá¾á”áŸ’ášá¶áŸáŸ‹ (USER DIRECTORY)</b>",
    "header_history": "ğŸ“œ <b>á”áŸ’ášáœááŸ’áá·á€á¶ášáŸá“áŸ’á‘á“á¶ (CHAT HISTORY)</b>",
    
    # Body Text
    "welcome_body": (
        "áŸá½áŸáŸ’áá¸ <b>{name}</b>! ğŸ‘‹\n"
        "á“áŸáŸ‡á‚áºá‡á¶á”áŸ’ášá–áŸá“áŸ’á’á‡áŸ†á“á½á™á€á¶ášá†áŸ’á›á¶ááœáŸƒáŸ” áŸá¼á˜á‡áŸ’ášá¾áŸášá¾áŸáŸáŸáœá¶á€á˜áŸ’á˜áá¶á„á€áŸ’ášáŸ„á˜áŸ–"
    ),
    "contact_intro": (
        "ğŸ’¬ <b>á…á¶á”áŸ‹á•áŸ’áá¾á˜á€á¶ášáŸá“áŸ’á‘á“á¶ (Start Chat)</b>\n\n"
        "ğŸ“ áŸá¼á˜áŸášáŸáŸášáŸáŸ†áá½ášášá”áŸáŸ‹á¢áŸ’á“á€á“áŸ…á‘á¸á“áŸáŸ‡áŸ”\n"
        "ğŸ“ <i>á™á¾á„á‘á‘á½á› á¢á€áŸ’áŸáš ášá¼á”á—á¶á– á“á·á„á¯á€áŸá¶ášáŸ”</i>"
    ),
    "info_text": (
        "ğŸ¢ <b>á¢áŸ†á–á¸á€áŸ’ášá»á˜á áŸŠá»á“ (Company Info)</b>\n"
        "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
        "â° <b>á€á¶á›áœá·á—á¶á‚ (Schedule):</b>\n"
        "ğŸŸ¢ á…á¼á›: 07:30 á–áŸ’ášá¹á€\n"
        "â˜• áŸá˜áŸ’ášá¶á€: 09:30-09:45 | 14:30-14:45\n"
        "ğŸ”´ á…áŸá‰: 05:30 á›áŸ’á„á¶á…\n\n"
        "ğŸ“ <b>á‘á¸áá¶áŸ†á„:</b> ášá¶á‡á’á¶á“á¸á—áŸ’á“áŸ†á–áŸá‰"
    ),
    "discipline_text": (
        "âš–ï¸ <b>áœá·á“áŸá™á€á¶ášá„á¶áš (Code of Conduct)</b>\n"
        "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
        "1ï¸âƒ£ <b>á¢á¶á€á”áŸ’á”á€á·ášá·á™á¶ (Attitude):</b> áŸáŸ’á˜áŸ„áŸ‡ááŸ’ášá„áŸ‹, á‚áŸ„ášá–, áŸá á€á¶ášáŸ”\n"
        "2ï¸âƒ£ <b>á€á¶ášá„á¶áš (Work):</b> á‘áŸ€á„á‘á¶ááŸ‹á˜áŸ‰áŸ„á„, á‘á‘á½á›áá»áŸááŸ’ášá¼áœáŸ”\n"
        "3ï¸âƒ£ <b>áŸááŸ’áá¶á”áŸ‹á’áŸ’á“á¶á”áŸ‹ (Discipline):</b> á¢á“á¶á˜áŸá™, áŸá»á‡á¸áœá’á˜áŸŒáŸ”"
    ),
    "ticket_created": (
        "ğŸ“¥ <b>á”á¶á“á‘á‘á½á›áŸáŸ†áá¾!</b>\n"
        "ğŸ†” <code>{ticket_id}</code>\n"
        "â³ áŸáŸ’áá¶á“á—á¶á–: <b>á€áŸ†á–á»á„ášá„áŸ‹á…á¶áŸ† (Pending)</b>\n\n"
        "<i>á€áŸ’ášá»á˜á€á¶ášá„á¶ášá“á¹á„á†áŸ’á›á¾á™áá”á€áŸ’á“á»á„á–áŸá›á†á¶á”áŸ‹áŸ—áŸ”</i>"
    ),
    "session_cleared": "â™»ï¸ <b>á€á¶ášáŸá“áŸ’á‘á“á¶ááŸ’ášá¼áœá”á¶á“á”á‰áŸ’á…á”áŸ‹áŸ”</b> (Session Reset)",
    "error_generic": "âš ï¸ á˜á¶á“á”á‰áŸ’á á¶á”á…áŸ’á…áŸá€á‘áŸáŸáŸ” áŸá¼á˜á–áŸ’á™á¶á™á¶á˜á˜áŸ’áá„á‘áŸ€ááŸ”",
    "admin_broadcast_success": "âœ… á”á¶á“á•áŸ’áŸá–áŸ’áœá•áŸ’áŸá¶á™á‘áŸ…á€á¶á“áŸ‹ {count} á“á¶á€áŸ‹áŸ”",
}

# --- LOGGING ---
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- DATABASE ENGINE ---
def init_db():
    conn = sqlite3.connect("relay_bot.db")
    c = conn.cursor()
    
    # Message Map (For Routing & History)
    c.execute('''
        CREATE TABLE IF NOT EXISTS message_map (
            admin_message_id INTEGER PRIMARY KEY,
            user_id INTEGER,
            user_name TEXT,
            ticket_id TEXT,
            question_text TEXT,
            created_at TIMESTAMP,
            status TEXT DEFAULT 'PENDING',
            answer_text TEXT,
            admin_responder TEXT
        )
    ''')
    
    # Users Registry (For /iduser & Broadcast)
    c.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            first_name TEXT,
            username TEXT,
            joined_at TIMESTAMP
        )
    ''')
    
    # Ensure columns exist (Migration safety)
    try: c.execute("ALTER TABLE message_map ADD COLUMN question_text TEXT")
    except: pass
    try: c.execute("ALTER TABLE message_map ADD COLUMN created_at TIMESTAMP")
    except: pass
    try: c.execute("ALTER TABLE message_map ADD COLUMN status TEXT DEFAULT 'PENDING'")
    except: pass
    try: c.execute("ALTER TABLE message_map ADD COLUMN answer_text TEXT")
    except: pass
    try: c.execute("ALTER TABLE message_map ADD COLUMN admin_responder TEXT")
    except: pass

    conn.commit()
    conn.close()

# --- DB HELPERS ---

def register_user(user):
    conn = sqlite3.connect("relay_bot.db")
    c = conn.cursor()
    c.execute("INSERT OR REPLACE INTO users (user_id, first_name, username, joined_at) VALUES (?, ?, ?, ?)",
              (user.id, user.first_name, user.username, datetime.now()))
    conn.commit()
    conn.close()

def get_all_users_details():
    conn = sqlite3.connect("relay_bot.db")
    c = conn.cursor()
    c.execute("SELECT user_id, first_name, username FROM users")
    data = c.fetchall()
    conn.close()
    return data

def get_all_users_ids():
    data = get_all_users_details()
    return [row[0] for row in data]

def save_ticket(admin_msg_id, user_id, user_name, ticket_id, question):
    conn = sqlite3.connect("relay_bot.db")
    c = conn.cursor()
    c.execute("INSERT OR REPLACE INTO message_map (admin_message_id, user_id, user_name, ticket_id, question_text, created_at, status) VALUES (?, ?, ?, ?, ?, ?, ?)", 
              (admin_msg_id, user_id, user_name, ticket_id, question, datetime.now(), 'PENDING'))
    conn.commit()
    conn.close()

def update_ticket_answer(admin_msg_id, answer, admin_name):
    conn = sqlite3.connect("relay_bot.db")
    c = conn.cursor()
    c.execute("UPDATE message_map SET status='SOLVED', answer_text=?, admin_responder=? WHERE admin_message_id=?", 
              (answer, admin_name, admin_msg_id))
    conn.commit()
    conn.close()

def get_ticket_context(admin_msg_id):
    conn = sqlite3.connect("relay_bot.db")
    c = conn.cursor()
    c.execute("SELECT user_id, user_name, ticket_id FROM message_map WHERE admin_message_id=?", (admin_msg_id,))
    result = c.fetchone()
    conn.close()
    return result

def get_ticket_history_by_id(ticket_id):
    conn = sqlite3.connect("relay_bot.db")
    c = conn.cursor()
    # Flexible query to match DI-72 or DI_72
    clean_id = ticket_id.replace('_', '-').strip()
    c.execute("SELECT * FROM message_map WHERE ticket_id = ?", (clean_id,))
    result = c.fetchone()
    conn.close()
    return result

def delete_user_history(user_id):
    conn = sqlite3.connect("relay_bot.db")
    c = conn.cursor()
    c.execute("DELETE FROM message_map WHERE user_id=?", (user_id,))
    conn.commit()
    conn.close()

# --- ADMIN COMMANDS ---

async def list_users_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Command: /iduser - View list of all users."""
    if update.effective_chat.id != ADMIN_GROUP_ID:
        return

    users = get_all_users_details()
    if not users:
        await update.message.reply_text("ğŸ“­ No users found in database.")
        return

    # Build the list
    msg = f"{LANG['header_userlist']}\n\n"
    msg += f"ğŸ“¦ <b>Total Users:</b> {len(users)}\n"
    msg += "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
    
    # Show last 30 users to prevent message overflow
    for uid, fname, uname in users[-30:]:
        u_display = f"@{uname}" if uname else "N/A"
        msg += f"ğŸ‘¤ <b>{fname}</b>\n   ğŸ†” <code>{uid}</code> | ğŸ”— {u_display}\n"
    
    if len(users) > 30:
        msg += "\n<i>...and {len(users)-30} more.</i>"

    await update.message.reply_html(msg)

async def ticket_lookup_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handles commands like /DI_72 or /DI-72
    Regex filter: ^/DI[-_]\d+
    """
    if update.effective_chat.id != ADMIN_GROUP_ID:
        return

    command = update.message.text.split()[0][1:] # Remove '/'
    ticket_id = command.replace('_', '-') # Normalize to DI-xxx

    row = get_ticket_history_by_id(ticket_id)

    if not row:
        await update.message.reply_text(f"âŒ Ticket {ticket_id} not found.")
        return

    # Unpack row (based on DB schema order)
    # admin_msg_id(0), user_id(1), user_name(2), ticket_id(3), question(4), date(5), status(6), answer(7), responder(8)
    
    t_id = row[3]
    u_name = row[2]
    u_id = row[1]
    q_text = row[4] or "[Media]"
    status = row[6]
    date_str = row[5]
    ans_text = row[7] or "No answer yet."
    responder = row[8] or "N/A"

    status_icon = "ğŸŸ¢" if status == 'SOLVED' else "ğŸŸ¡"
    
    msg = (
        f"{LANG['header_history']}\n"
        f"â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
        f"ğŸ« <b>{t_id}</b> {status_icon} <b>{status}</b>\n"
        f"ğŸ“… {date_str}\n\n"
        f"ğŸ‘¤ <b>User Info:</b>\n"
        f"   â€¢ Name: {u_name}\n"
        f"   â€¢ ID: <code>{u_id}</code>\n\n"
        f"ğŸ’¬ <b>Question:</b>\n"
        f"   {q_text}\n\n"
        f"â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
    )
    
    if status == 'SOLVED':
        msg += (
            f"ğŸ‘¨â€ğŸ’¼ <b>Answered By:</b> {responder}\n"
            f"ğŸ“ <b>Response:</b>\n"
            f"   {ans_text}"
        )
    else:
        msg += "<i>Waiting for support team reply...</i>"

    await update.message.reply_html(msg)

async def report_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Command: /report [all]"""
    if update.effective_chat.id != ADMIN_GROUP_ID:
        return

    args = context.args
    
    if args and args[0].lower() in ['all', 'full', 'csv']:
        # CSV Export Logic
        conn = sqlite3.connect("relay_bot.db")
        c = conn.cursor()
        c.execute("SELECT ticket_id, user_name, question_text, status, created_at, admin_responder FROM message_map ORDER BY created_at DESC")
        data = c.fetchall()
        conn.close()

        output = io.StringIO()
        writer = csv.writer(output)
        writer.writerow(['Ticket ID', 'User Name', 'Question', 'Status', 'Date', 'Admin Responder'])
        writer.writerows(data)
        
        # Add BOM for Excel compatibility
        bio = io.BytesIO(b'\xef\xbb\xbf' + output.getvalue().encode('utf-8'))
        bio.name = f"Full_Report_{date.today()}.csv"
        
        await context.bot.send_document(chat_id=ADMIN_GROUP_ID, document=bio, caption="ğŸ“Š <b>Full Export</b>", parse_mode=ParseMode.HTML)
        return

    # Summary Stats
    conn = sqlite3.connect("relay_bot.db")
    c = conn.cursor()
    c.execute("SELECT COUNT(*), SUM(CASE WHEN status='PENDING' THEN 1 ELSE 0 END) FROM message_map")
    stats = c.fetchone()
    total, pending = stats[0], stats[1] or 0
    
    c.execute("SELECT ticket_id, user_name, question_text FROM message_map WHERE status='PENDING' ORDER BY created_at DESC LIMIT 5")
    recent = c.fetchall()
    conn.close()

    msg = (
        f"{LANG['header_report']}\n"
        f"â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
        f"ğŸ“ˆ <b>All Time:</b> {total}\n"
        f"â³ <b>Pending:</b> {pending}\n\n"
        f"ğŸ“‹ <b>Recent Unanswered:</b>\n"
    )
    
    if recent:
        for t in recent:
            q = (t[2][:30] + '..') if t[2] else "Media"
            msg += f"â€¢ <code>{t[0]}</code> | {t[1]}: {q}\n"
    else:
        msg += "âœ¨ <i>All clear! No pending tickets.</i>"

    await update.message.reply_html(msg)

# --- USER HANDLERS ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user
    register_user(user)

    # Clean Grid Layout
    keyboard = [
        [InlineKeyboardButton("ğŸ’¬ á‡áŸ†á“á½á™ (Support)", callback_data="btn_support"), InlineKeyboardButton("ğŸ¢ á–áŸááŸŒá˜á¶á“ (Info)", callback_data="btn_info")],
        [InlineKeyboardButton("âš–ï¸ áœá·á“áŸá™ (Rules)", callback_data="btn_discipline"), InlineKeyboardButton("ğŸ§¹ Clear Chat", callback_data="btn_clear")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_html(
        f"{LANG['header_welcome']}\n\n" + 
        LANG['welcome_body'].format(name=user.first_name),
        reply_markup=reply_markup
    )

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer() 

    if query.data == "btn_support":
        await query.message.reply_html(LANG["contact_intro"])
    elif query.data == "btn_info":
        await query.message.reply_html(LANG["info_text"])
    elif query.data == "btn_discipline":
        await query.message.reply_html(LANG["discipline_text"])
    elif query.data == "btn_clear":
        delete_user_history(query.from_user.id)
        await query.message.reply_html(LANG["session_cleared"])

async def handle_user_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.effective_chat.id == ADMIN_GROUP_ID:
        return

    if update.message.text and update.message.text.upper() == "CLEAR":
        delete_user_history(update.effective_user.id)
        await update.message.reply_html(LANG["session_cleared"])
        return

    user = update.effective_user
    register_user(user)
    
    ticket_id = f"DI-{update.message.message_id}"
    question_content = update.message.text or "[Media/File]"
    
    # Modern Admin Notification Card
    admin_text = (
        f"{LANG['header_ticket']} <code>{ticket_id}</code>\n"
        f"â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
        f"ğŸ‘¤ <b>User:</b> {user.full_name}\n"
        f"ğŸ”— <b>Link:</b> @{user.username or 'NoUser'}\n"
        f"ğŸ†” <b>ID:</b> <code>{user.id}</code>\n\n"
    )

    sent_msg = None
    try:
        if update.message.text:
            admin_text += f"ğŸ’¬ <b>Question:</b>\n{update.message.text}"
            sent_msg = await context.bot.send_message(chat_id=ADMIN_GROUP_ID, text=admin_text, parse_mode=ParseMode.HTML)
        
        elif update.message.photo:
            admin_text += f"ğŸ–¼ <b>Photo Sent</b>\n{update.message.caption or ''}"
            sent_msg = await context.bot.send_photo(chat_id=ADMIN_GROUP_ID, photo=update.message.photo[-1].file_id, caption=admin_text, parse_mode=ParseMode.HTML)
            
        elif update.message.document:
            admin_text += f"ğŸ“‚ <b>Document Sent</b>\n{update.message.caption or ''}"
            sent_msg = await context.bot.send_document(chat_id=ADMIN_GROUP_ID, document=update.message.document.file_id, caption=admin_text, parse_mode=ParseMode.HTML)

        if sent_msg:
            save_ticket(sent_msg.message_id, user.id, user.full_name, ticket_id, question_content)
            # Confirmation to user
            await update.message.reply_html(LANG["ticket_created"].format(ticket_id=ticket_id))

    except Exception as e:
        logger.error(f"Relay Error: {e}")
        await update.message.reply_text(LANG["error_generic"])

async def handle_admin_reply(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.effective_chat.id != ADMIN_GROUP_ID or not update.message.reply_to_message:
        return 

    replied_msg_id = update.message.reply_to_message.message_id
    mapping = get_ticket_context(replied_msg_id)
    
    if mapping:
        user_id, user_name, ticket_id = mapping
        admin_name = update.effective_user.full_name or "Support Agent"
        answer_content = update.message.text or "[Media/File]"
        
        try:
            header = f"{LANG['header_reply']}"
            
            if update.message.text:
                await context.bot.send_message(chat_id=user_id, text=f"{header}{update.message.text}", parse_mode=ParseMode.HTML)
            elif update.message.photo:
                await context.bot.send_photo(chat_id=user_id, photo=update.message.photo[-1].file_id, caption=f"{header}{update.message.caption or ''}", parse_mode=ParseMode.HTML)
            elif update.message.voice:
                await context.bot.send_voice(chat_id=user_id, voice=update.message.voice.file_id, caption=header, parse_mode=ParseMode.HTML)

            update_ticket_answer(replied_msg_id, answer_content, admin_name)
            await update.message.reply_text(f"âœ… <b>Sent to {user_name}</b>\nTicket marked as SOLVED by {admin_name}", parse_mode=ParseMode.HTML)
            
        except Exception as e:
            await update.message.reply_text(f"âŒ Failed to send: {e}")
    else:
        # Check if they are trying to command the bot
        if not update.message.text.startswith("/"):
            await update.message.reply_text("âš ï¸ Ticket context lost (Old message).")

async def broadcast_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.effective_chat.id != ADMIN_GROUP_ID: return
    msg = " ".join(context.args)
    if not msg: 
        await update.message.reply_text("Usage: /broadcast [Message]")
        return
    
    ids = get_all_users_ids()
    count = 0
    formatted = f"{LANG['header_broadcast']}\n\n{msg}"
    
    status = await update.message.reply_text(f"â³ Sending to {len(ids)} users...")
    for uid in ids:
        try:
            await context.bot.send_message(chat_id=uid, text=formatted, parse_mode=ParseMode.HTML)
            count += 1
        except: pass
    await status.edit_text(LANG["admin_broadcast_success"].format(count=count))

def main() -> None:
    init_db()
    application = Application.builder().token(BOT_TOKEN).build()

    # Admin Commands
    application.add_handler(CommandHandler("broadcast", broadcast_command))
    application.add_handler(CommandHandler("report", report_command))
    application.add_handler(CommandHandler("iduser", list_users_command)) # NEW
    
    # NEW: Smart Ticket Lookup Handler (Matches /DI-123 or /DI_123)
    application.add_handler(MessageHandler(filters.Regex(r'^/DI[-_]\d+'), ticket_lookup_handler))

    # User Interactions
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("clear", start))
    application.add_handler(CallbackQueryHandler(button_handler))

    # Core Messaging
    application.add_handler(MessageHandler(
        filters.ChatType.PRIVATE & ~filters.COMMAND & (filters.TEXT | filters.PHOTO | filters.Document.ALL | filters.VOICE),
        handle_user_message
    ))

    # Admin Replies
    application.add_handler(MessageHandler(filters.Chat(chat_id=ADMIN_GROUP_ID) & filters.REPLY, handle_admin_reply))

    print("Enterprise Platinum Final Bot is running...")
    application.run_polling()

if __name__ == "__main__":
    main()