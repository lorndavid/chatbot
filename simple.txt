import logging
import sqlite3
import csv
import io
from datetime import datetime, date, timedelta
from typing import Optional
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ContextTypes,
    filters,
)

# --- CONFIGURATION ---
# Replace with your actual values
BOT_TOKEN = "8420582565:AAHM4qR-nN6iheHTO20TnEYFfJqngb5mVco"
ADMIN_GROUP_ID = -1003238857423  # Your Admin Group ID

# --- KHMER LANGUAGE & UI CONSTANTS (Platinum Style) ---
LANG = {
    # Headers
    "header_welcome": "ğŸ¢ <b>á”áŸ’ášá–áŸá“áŸ’á’á‡áŸ†á“á½á™á¢áá·áá·á‡á“ á“á·á„á‘áŸ†á“á¶á€áŸ‹á‘áŸ†á“á„</b>",
    "header_ticket": "ğŸŸ <b>á”áŸááŸ’áá‘á‘á½á›áŸáŸ†áá¾ (TICKET RECEIPT)</b>",
    "header_reply": "ğŸ‘¨â€ğŸ’¼ <b>á€á¶ášá†áŸ’á›á¾á™áá”á–á¸á•áŸ’á“áŸ‚á€á‡áŸ†á“á½á™ (SUPPORT TEAM):</b>\n",
    "header_broadcast": "ğŸ“¢ <b>áŸáŸá…á€áŸ’áá¸á‡á¼á“áŠáŸ†áá¹á„á–á¸á€áŸ’ášá»á˜á áŸŠá»á“ (ANNOUNCEMENT)</b>",
    "header_report": "ğŸ“Š <b>ášá”á¶á™á€á¶ášááŸáŸá„áŸ’ááŸá” (DAILY REPORT)</b>",
    
    # Body Text
    "welcome_body": (
        "áŸá¼á˜áŸáŸ’áœá¶á‚á˜á“áŸ <b>{name}</b> á˜á€á€á¶á“áŸ‹á”áŸ’ášá–áŸá“áŸ’á’áŸáŸ’áœáŸá™á”áŸ’ášáœááŸ’áá·ášá”áŸáŸ‹á™á¾á„ááŸ’á‰á»áŸ†áŸ”\n\n"
        "á™á¾á„ááŸ’á‰á»áŸ†ááŸ’ášáŸ€á˜ááŸ’á›á½á“á‡á¶áŸáŸ’ášáŸá…áŠá¾á˜áŸ’á”á¸á‡á½á™á›áŸ„á€á¢áŸ’á“á€áŸ” áŸá¼á˜á‡áŸ’ášá¾áŸášá¾áŸáŸáŸáœá¶á€á˜áŸ’á˜áá¶á„á€áŸ’ášáŸ„á˜áŸ–"
    ),
    "contact_intro": (
        "ğŸ’¬ <b>á€á¶ášáŸá“áŸ’á‘á“á¶á‡á¶á˜á½á™á—áŸ’á“á¶á€áŸ‹á„á¶áš</b>\n\n"
        "áŸá¼á˜á›áŸ„á€á¢áŸ’á“á€áŸášáŸáŸášáŸá¶áš á”á‰áŸ’á á¶ á¬áŸáŸ†áá½áš á á¾á™á•áŸ’á‰á¾á˜á€á€á¶á“áŸ‹á™á¾á„ááŸ’á‰á»áŸ†á¥á¡á¼áœá“áŸáŸ‡áŸ”\n"
        "<i>(á¢á¶á…á•áŸ’á‰á¾á‡á¶á¢á€áŸ’áŸáš ášá¼á”á—á¶á– á¬á¯á€áŸá¶ášá”á¶á“)</i>"
    ),
    "info_text": (
        "ğŸ¢ <b>á¢áŸ†á–á¸á€áŸ’ášá»á˜á áŸŠá»á“ á“á·á„á˜áŸ‰áŸ„á„á’áŸ’áœá¾á€á¶áš (Company Info)</b>\n\n"
        "á™á¾á„á”áŸ’ááŸá‡áŸ’á‰á¶á•áŸ’áá›áŸ‹á‡á¼á“á“á¼áœá”ášá·á™á¶á€á¶áŸá€á¶ášá„á¶ášá”áŸ’ášá€á”áŠáŸ„á™áœá·á‡áŸ’á‡á¶á‡á¸áœáŸˆ á“á·á„á”áŸ’ášáŸá·á‘áŸ’á’á—á¶á–ááŸ’á–áŸáŸ‹áŸ”\n\n"
        "â° <b>á€á¶á›áœá·á—á¶á‚á€á¶ášá„á¶áš (Working Schedule):</b>\n"
        "ğŸŸ¢ <b>á˜áŸ‰áŸ„á„á…á¼á›á’áŸ’áœá¾á€á¶áš:</b> 07:30 á–áŸ’ášá¹á€\n"
        "â˜• <b>áŸá˜áŸ’ášá¶á€á–áŸá›á–áŸ’ášá¹á€:</b> 09:30 - 09:45 á–áŸ’ášá¹á€\n"
        "â˜• <b>áŸá˜áŸ’ášá¶á€á–áŸá›ášáŸáŸ€á›:</b> 02:30 - 02:45 ášáŸáŸ€á›\n"
        "ğŸ”´ <b>á˜áŸ‰áŸ„á„á…áŸá‰á’áŸ’áœá¾á€á¶áš:</b> 05:30 á›áŸ’á„á¶á…\n\n"
        "ğŸ“ <b>á‘á¸áá¶áŸ†á„:</b> ášá¶á‡á’á¶á“á¸á—áŸ’á“áŸ†á–áŸá‰, á€á˜áŸ’á–á»á‡á¶"
    ),
    "discipline_text": (
        "ğŸ“œ <b>áœá·á“áŸá™ á“á·á„á‚áŸ„á›á€á¶ášááŸá€á¶ášá„á¶ášá€áŸ’á“á»á„ DI</b>\n\n"
        "áŠá¾á˜áŸ’á”á¸ášá€áŸ’áŸá¶á”á¶á“á“á¼áœáŸáŸ’áá„áŸ‹áŠá¶ášá€á¶ášá„á¶ášááŸ’á–áŸáŸ‹ á“á·á„áœá”áŸ’á”á’á˜áŸŒá›áŸ’á¢á”áŸ’ášáŸá¾áš á™á¾á„áŸá¼á˜ááŸ‚á“á¶áŸ†á“á¼áœá…áŸ†áá»á…áŸáŸ†áá¶á“áŸ‹áŸ—áŸ–\n\n"
        "1ï¸âƒ£ <b>á¥ášá·á™á¶á”á á“á·á„áŸá¸á›á’á˜áŸŒ (Attitude):</b>\n"
        "â€¢ ááŸ’ášá¼áœá˜á¶á“á—á¶á–áŸáŸ’á˜áŸ„áŸ‡ááŸ’ášá„áŸ‹ á“á·á„á€á¶ášá‚áŸ„ášá–á‚áŸ’á“á¶á‘áŸ…áœá·á‰á‘áŸ…á˜á€áŸ”\n"
        "â€¢ ášá€áŸ’áŸá¶á‘áŸ†á“á¶á€áŸ‹á‘áŸ†á“á„á›áŸ’á¢á‡á¶á˜á½á™áŸá á€á¶ášá¸ á“á·á„á¢áá·áá·á‡á“áŸ”\n"
        "â€¢ á˜á¶á“áŸáŸ’á˜á¶ášáá¸áŸá á€á¶ášá‡á¶á€áŸ’ášá»á˜ (Teamwork) á“á·á„á‡á½á™á‚áŸ’á“á¶á‘áŸ…áœá·á‰á‘áŸ…á˜á€áŸ”\n\n"
        "2ï¸âƒ£ <b>á€á¶ášá”áŸ†á–áŸá‰á€á¶ášá„á¶áš (Work Ethics):</b>\n"
        "â€¢ ááŸ’ášá¼áœá˜á€á’áŸ’áœá¾á€á¶ášá±áŸ’á™á‘á¶á“áŸ‹á–áŸá›áœáŸá›á¶áŠáŸ‚á›á”á¶á“á€áŸ†áááŸ‹ (áŸ§:áŸ£áŸ  á–áŸ’ášá¹á€)áŸ”\n"
        "â€¢ á‘á‘á½á›áá»áŸááŸ’ášá¼áœááŸ’á–áŸáŸ‹á›á¾á—á¶ášá€á·á…áŸ’á…áŠáŸ‚á›á”á¶á“á”áŸ’ášá‚á›áŸ‹á‡á¼á“áŸ”\n"
        "â€¢ á–áŸ’á™á¶á™á¶á˜á¢á—á·áœáŒáŸ’ááŸá˜ááŸ’áá—á¶á–ááŸ’á›á½á“á¯á„á‡á¶á”áŸ’ášá…á¶áŸ†áŸ”\n\n"
        "3ï¸âƒ£ <b>áœá·á“áŸá™á‘á¼á‘áŸ… (General Discipline):</b>\n"
        "â€¢ á‚áŸ„ášá–áá¶á˜á”á‘á”á‰áŸ’á‡á¶á•áŸ’á‘áŸƒá€áŸ’á“á»á„ášá”áŸáŸ‹á€áŸ’ášá»á˜á áŸŠá»á“á™áŸ‰á¶á„á˜áŸ‰áºá„á˜áŸ‰á¶ááŸ‹áŸ”\n"
        "â€¢ á…á¼á›ášá½á˜ááŸ‚ášá€áŸ’áŸá¶áŸááŸ’áá¶á”áŸ‹á’áŸ’á“á¶á”áŸ‹ á“á·á„á¢á“á¶á˜áŸá™á€á“áŸ’á›áŸ‚á„á’áŸ’áœá¾á€á¶ášáŸ”\n"
        "â€¢ á”áŸ’ášá¾á”áŸ’ášá¶áŸáŸ‹á–áŸá›áŸá˜áŸ’ášá¶á€ (Break Time) á±áŸ’á™á”á¶á“ááŸ’ášá¹á˜ááŸ’ášá¼áœáŸ”\n\n"
        "âœ¨ <i>á—á¶á–á‡áŸ„á‚á‡áŸá™ášá”áŸáŸ‹á¢áŸ’á“á€ á‚áºá‡á¶á‡áŸ„á‚á‡áŸá™ášá”áŸáŸ‹á™á¾á„á‘á¶áŸ†á„á¢áŸáŸ‹á‚áŸ’á“á¶!</i>"
    ),
    "ticket_created": (
        "âœ… <b>á”á¶á“á‘á‘á½á›á‡áŸ„á‚á‡áŸá™!</b>\n"
        "--------------------------\n"
        "ğŸ”¢ á€á¼áŠ-User: <code>{ticket_id}</code>\n"
        "ğŸ•’ áŸáŸ’áá¶á“á—á¶á–: <b>á€áŸ†á–á»á„ááŸ’ášá½áá–á·á“á·ááŸ’á™ (Pending)</b>\n\n"
        "á€áŸ’ášá»á˜á€á¶ášá„á¶ášá“á¹á„á†áŸ’á›á¾á™áá”á‡á¼á“á›áŸ„á€á¢áŸ’á“á€á€áŸ’á“á»á„á–áŸá›á”á“áŸ’áá·á…á‘áŸ€áá“áŸáŸ‡áŸ”"
    ),
    "session_cleared": "âœ… <b>á€á¶ášáŸá“áŸ’á‘á“á¶ááŸ’ášá¼áœá”á¶á“á”á‰áŸ’á…á”áŸ‹áŸ”</b>\ná›áŸ„á€á¢áŸ’á“á€á¢á¶á…á…á¶á”áŸ‹á•áŸ’áá¾á˜ááŸ’á˜á¸áŠáŸ„á™á…á»á… /start",
    "error_generic": "âš ï¸ áŸá¼á˜á¢á—áŸá™á‘áŸ„áŸ á”áŸ’ášá–áŸá“áŸ’á’á˜á¶á“á”á‰áŸ’á á¶á”á…áŸ’á…áŸá€á‘áŸáŸáŸ”",
    "admin_broadcast_success": "âœ… á”á¶á“á•áŸ’á‰á¾áŸá¶ášá‡á¼á“áŠáŸ†áá¹á„á‘áŸ…á€á¶á“áŸ‹á¢áŸ’á“á€á”áŸ’ášá¾á”áŸ’ášá¶áŸáŸ‹á…áŸ†á“á½á“ {count} á“á¶á€áŸ‹áŸ”",
}

# --- LOGGING ---
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- DATABASE ENGINE ---
def init_db():
    conn = sqlite3.connect("relay_bot.db")
    c = conn.cursor()
    
    # Core Tables
    c.execute('''
        CREATE TABLE IF NOT EXISTS message_map (
            admin_message_id INTEGER PRIMARY KEY,
            user_id INTEGER,
            user_name TEXT,
            ticket_id TEXT,
            question_text TEXT,
            created_at TIMESTAMP,
            status TEXT DEFAULT 'PENDING',
            answer_text TEXT,
            admin_responder TEXT
        )
    ''')
    
    c.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            first_name TEXT,
            username TEXT,
            joined_at TIMESTAMP
        )
    ''')
    
    # Attempt to upgrade existing tables if columns are missing
    try:
        c.execute("ALTER TABLE message_map ADD COLUMN question_text TEXT")
    except sqlite3.OperationalError: pass
    try:
        c.execute("ALTER TABLE message_map ADD COLUMN created_at TIMESTAMP")
    except sqlite3.OperationalError: pass
    try:
        c.execute("ALTER TABLE message_map ADD COLUMN status TEXT DEFAULT 'PENDING'")
    except sqlite3.OperationalError: pass
    try:
        c.execute("ALTER TABLE message_map ADD COLUMN answer_text TEXT")
    except sqlite3.OperationalError: pass
    try:
        c.execute("ALTER TABLE message_map ADD COLUMN admin_responder TEXT")
    except sqlite3.OperationalError: pass

    conn.commit()
    conn.close()

def register_user(user):
    conn = sqlite3.connect("relay_bot.db")
    c = conn.cursor()
    c.execute("INSERT OR REPLACE INTO users (user_id, first_name, username, joined_at) VALUES (?, ?, ?, ?)",
              (user.id, user.first_name, user.username, datetime.now()))
    conn.commit()
    conn.close()

def get_all_users():
    conn = sqlite3.connect("relay_bot.db")
    c = conn.cursor()
    c.execute("SELECT user_id FROM users")
    users = [row[0] for row in c.fetchall()]
    conn.close()
    return users

def save_message_map(admin_msg_id, user_id, user_name, ticket_id, question_text):
    conn = sqlite3.connect("relay_bot.db")
    c = conn.cursor()
    c.execute("INSERT OR REPLACE INTO message_map (admin_message_id, user_id, user_name, ticket_id, question_text, created_at, status) VALUES (?, ?, ?, ?, ?, ?, ?)", 
              (admin_msg_id, user_id, user_name, ticket_id, question_text, datetime.now(), 'PENDING'))
    conn.commit()
    conn.close()

def update_message_answered(admin_msg_id, answer_text, admin_name):
    conn = sqlite3.connect("relay_bot.db")
    c = conn.cursor()
    c.execute("UPDATE message_map SET status='SOLVED', answer_text=?, admin_responder=? WHERE admin_message_id=?", 
              (answer_text, admin_name, admin_msg_id))
    conn.commit()
    conn.close()

def get_original_user(admin_msg_id) -> Optional[tuple]:
    conn = sqlite3.connect("relay_bot.db")
    c = conn.cursor()
    c.execute("SELECT user_id, user_name, ticket_id FROM message_map WHERE admin_message_id=?", (admin_msg_id,))
    result = c.fetchone()
    conn.close()
    return result

def delete_user_history(user_id):
    conn = sqlite3.connect("relay_bot.db")
    c = conn.cursor()
    # Only delete from map, keep user registry
    c.execute("DELETE FROM message_map WHERE user_id=?", (user_id,))
    conn.commit()
    conn.close()

# --- REPORTING FUNCTIONS ---

def get_report_data(limit=None):
    conn = sqlite3.connect("relay_bot.db")
    c = conn.cursor()
    query = "SELECT ticket_id, user_name, question_text, status, created_at, admin_responder FROM message_map ORDER BY created_at DESC"
    if limit:
        query += f" LIMIT {limit}"
    c.execute(query)
    data = c.fetchall()
    conn.close()
    return data

def get_stats_summary():
    conn = sqlite3.connect("relay_bot.db")
    c = conn.cursor()
    
    # Total tickets
    c.execute("SELECT COUNT(*) FROM message_map")
    total = c.fetchone()[0]
    
    # Pending
    c.execute("SELECT COUNT(*) FROM message_map WHERE status='PENDING'")
    pending = c.fetchone()[0]
    
    # Today's tickets
    today_start = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
    c.execute("SELECT COUNT(*) FROM message_map WHERE created_at >= ?", (today_start,))
    today_count = c.fetchone()[0]
    
    conn.close()
    return total, pending, today_count

# --- COMMAND HANDLERS ---

async def report_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Admin Command: /report [all]
    - /report: Shows summary stats and last 5 pending tickets.
    - /report all: Generates a CSV file of ALL tickets.
    """
    if update.effective_chat.id != ADMIN_GROUP_ID:
        return

    args = context.args
    
    # --- CSV EXPORT (Full History) ---
    if args and args[0].lower() in ['all', 'full', 'csv']:
        await update.message.reply_text("â³ Generating full history report...")
        
        data = get_report_data() # Fetch all
        
        # Create CSV in memory
        output = io.StringIO()
        writer = csv.writer(output)
        writer.writerow(['Ticket ID', 'User Name', 'Question', 'Status', 'Date', 'Admin Responder'])
        writer.writerows(data)
        output.seek(0)
        
        # Convert to bytes for Telegram
        bio = io.BytesIO(output.read().encode('utf-8'))
        bio.name = f"Support_Report_{date.today()}.csv"
        
        await context.bot.send_document(
            chat_id=ADMIN_GROUP_ID,
            document=bio,
            caption=f"{LANG['header_report']}\n\nHere is the full conversation history.",
            parse_mode=ParseMode.HTML
        )
        return

    # --- DASHBOARD SUMMARY (Default) ---
    total, pending, today = get_stats_summary()
    
    # Get last 5 pending tickets
    conn = sqlite3.connect("relay_bot.db")
    c = conn.cursor()
    c.execute("SELECT ticket_id, user_name, question_text, created_at FROM message_map WHERE status='PENDING' ORDER BY created_at DESC LIMIT 5")
    recent_pending = c.fetchall()
    conn.close()
    
    summary_msg = (
        f"{LANG['header_report']}\n\n"
        f"ğŸ“… <b>Date:</b> {date.today()}\n"
        f"ğŸ“¬ <b>Total Tickets (All Time):</b> {total}\n"
        f"ğŸ†• <b>Tickets Today:</b> {today}\n"
        f"â³ <b>Pending (Unanswered):</b> {pending}\n\n"
        f"ğŸ“‹ <b>Recent Unanswered Questions:</b>\n"
    )
    
    if not recent_pending:
        summary_msg += "<i>No pending tickets! Great job team. ğŸ‰</i>"
    else:
        for t in recent_pending:
            # Truncate long questions
            q_preview = (t[2][:40] + '..') if t[2] and len(t[2]) > 40 else (t[2] or "Photo/File")
            summary_msg += f"â€¢ <code>{t[0]}</code> | {t[1]}: {q_preview}\n"
            
    summary_msg += "\nğŸ’¡ <i>Type <code>/report all</code> to download full history.</i>"

    await update.message.reply_html(summary_msg)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Professional Welcome Menu."""
    user = update.effective_user
    register_user(user)

    keyboard = [
        [
            InlineKeyboardButton("ğŸ’¬ á‡áŸ†á“á½á™á”á…áŸ’á…áŸá€á‘áŸáŸ (Support)", callback_data="btn_support"),
            InlineKeyboardButton("ğŸ¢ á˜áŸ‰áŸ„á„á’áŸ’áœá¾á€á¶áš (Info)", callback_data="btn_info")
        ],
        [
            InlineKeyboardButton("ğŸ“œ áœá·á“áŸá™á€áŸ’á“á»á„ DI (Discipline)", callback_data="btn_discipline")
        ],
        [
            InlineKeyboardButton("ğŸ§¹ á”á‰áŸ’á…á”áŸ‹á€á¶ášáŸá“áŸ’á‘á“á¶ (End Chat)", callback_data="btn_clear")
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_html(
        f"{LANG['header_welcome']}\n\n" + 
        LANG['welcome_body'].format(name=user.first_name),
        reply_markup=reply_markup
    )

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer() 

    if query.data == "btn_support":
        await query.message.reply_html(LANG["contact_intro"])
    elif query.data == "btn_info":
        await query.message.reply_html(LANG["info_text"])
    elif query.data == "btn_discipline":
        await query.message.reply_html(LANG["discipline_text"])
    elif query.data == "btn_clear":
        delete_user_history(query.from_user.id)
        await query.message.reply_html(LANG["session_cleared"])

async def handle_user_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.effective_chat.id == ADMIN_GROUP_ID:
        return

    if update.message.text and update.message.text.upper() == "CLEAR":
        delete_user_history(update.effective_user.id)
        await update.message.reply_html(LANG["session_cleared"])
        return

    user = update.effective_user
    register_user(user)
    
    ticket_id = f"DI-{update.message.message_id}"
    question_content = update.message.text or "[Media/File]"
    
    admin_text = (
        f"ğŸ“© <b>User_ID:</b> {ticket_id}\n"
        f"ğŸ‘¤ <b>Username:</b> {user.full_name} (@{user.username or 'NoUser'})\n"
        f"ğŸ†” <b>ID_telegram:</b> <code>{user.id}</code>\n"
    )

    sent_msg = None
    try:
        if update.message.text:
            admin_text += f"ğŸ’¬ <b>Question:</b>\n{update.message.text}"
            sent_msg = await context.bot.send_message(
                chat_id=ADMIN_GROUP_ID, 
                text=admin_text + "\n\nğŸ‘‰ <i>Reply to answer</i>", 
                parse_mode=ParseMode.HTML
            )
        elif update.message.photo:
            photo = update.message.photo[-1].file_id
            caption = update.message.caption or "No Caption"
            admin_text += f"ğŸ–¼ <b>Photo Sent</b>\nğŸ“ {caption}"
            sent_msg = await context.bot.send_photo(
                chat_id=ADMIN_GROUP_ID,
                photo=photo,
                caption=admin_text + "\n\nğŸ‘‰ <i>Reply to answer</i>",
                parse_mode=ParseMode.HTML
            )
        elif update.message.document:
            doc = update.message.document.file_id
            caption = update.message.caption or "No Caption"
            admin_text += f"ğŸ“‚ <b>File Sent</b>\nğŸ“ {caption}"
            sent_msg = await context.bot.send_document(
                chat_id=ADMIN_GROUP_ID,
                document=doc,
                caption=admin_text + "\n\nğŸ‘‰ <i>Reply to answer</i>",
                parse_mode=ParseMode.HTML
            )

        if sent_msg:
            # SAVE FULL CONTEXT
            save_message_map(sent_msg.message_id, user.id, user.full_name, ticket_id, question_content)
            await update.message.reply_html(LANG["ticket_created"].format(ticket_id=ticket_id))

    except Exception as e:
        logger.error(f"Relay Error: {e}")
        await update.message.reply_text(LANG["error_generic"])

async def handle_admin_reply(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.effective_chat.id != ADMIN_GROUP_ID or not update.message.reply_to_message:
        return 

    replied_msg_id = update.message.reply_to_message.message_id
    mapping = get_original_user(replied_msg_id)
    
    if mapping:
        user_id, user_name, ticket_id = mapping
        admin_name = update.effective_user.first_name
        answer_content = update.message.text or "[Media/File]"
        
        try:
            header = f"{LANG['header_reply']}"
            
            if update.message.text:
                await context.bot.send_message(
                    chat_id=user_id, 
                    text=f"{header}{update.message.text}", 
                    parse_mode=ParseMode.HTML
                )
            elif update.message.photo:
                photo = update.message.photo[-1].file_id
                caption = update.message.caption or ""
                await context.bot.send_photo(
                    chat_id=user_id, 
                    photo=photo, 
                    caption=f"{header}{caption}", 
                    parse_mode=ParseMode.HTML
                )
            elif update.message.voice:
                voice = update.message.voice.file_id
                await context.bot.send_voice(
                    chat_id=user_id,
                    voice=voice,
                    caption=header,
                    parse_mode=ParseMode.HTML
                )

            # UPDATE DB AS SOLVED
            update_message_answered(replied_msg_id, answer_content, admin_name)
            
            await update.message.reply_text(f"âœ… Reply sent to {user_name} (Marked SOLVED).")
            
        except Exception as e:
            await update.message.reply_text(f"âŒ Failed (User blocked bot?): {e}")
    else:
        await update.message.reply_text("âš ï¸ Ticket context lost (Old message).")

async def broadcast_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.effective_chat.id != ADMIN_GROUP_ID:
        return

    message = " ".join(context.args)
    if not message:
        await update.message.reply_text("âš ï¸ Usage: /broadcast [Your Message Here]")
        return

    users = get_all_users()
    count = 0
    formatted_msg = f"{LANG['header_broadcast']}\n\n{message}"
    status_msg = await update.message.reply_text(f"â³ Broadcasting to {len(users)} users...")

    for uid in users:
        try:
            await context.bot.send_message(chat_id=uid, text=formatted_msg, parse_mode=ParseMode.HTML)
            count += 1
        except Exception: pass
    
    await status_msg.edit_text(LANG["admin_broadcast_success"].format(count=count))

def main() -> None:
    init_db()
    application = Application.builder().token(BOT_TOKEN).build()

    # Admin Commands
    application.add_handler(CommandHandler("broadcast", broadcast_command))
    application.add_handler(CommandHandler("report", report_command)) # New Report Cmd

    # User Commands
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("clear", start))
    application.add_handler(CallbackQueryHandler(button_handler))

    # Messages
    application.add_handler(MessageHandler(
        filters.ChatType.PRIVATE & ~filters.COMMAND & 
        (filters.TEXT | filters.PHOTO | filters.Document.ALL | filters.VOICE),
        handle_user_message
    ))

    # Admin Replies
    application.add_handler(MessageHandler(
        filters.Chat(chat_id=ADMIN_GROUP_ID) & filters.REPLY, 
        handle_admin_reply
    ))

    print("Enterprise Platinum Bot 2.0 (With Reports) is running...")
    application.run_polling()

if __name__ == "__main__":
    main()